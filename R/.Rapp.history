source("kernels.R", chdir = TRUE)#
source("source.R") # R code for generating the FHT data#
#
nobs = 100#
p = 200#
rho = 0.9#
#
X=genx2(nobs,p,rho)#
y=genjerry(X,3)#
## initialize kernel function#
rbf <- polydot(degree = 1, scale = 1, offset = 1)#
#
## calculate kernel matrix#
Kmat <- kernelMatrix(rbf,X)
ulam  <-  c(0.4,0.5,0.6,0.7)#
ulam <- 0.4#
omega  <-  0.3#
omega <- as.double(omega)#
mbd <- 2 * max(1-omega, omega)#
nlam <- length(ulam)#
eps <- 10e-12#
maxit  <-  25
ulam  <-  c(0.4,0.5,0.6,0.7)#
omega  <-  0.3#
omega <- as.double(omega)#
mbd <- 2 * max(1-omega, omega)#
nlam <- length(ulam)#
eps <- 10e-12#
maxit  <-  25
ulam  <-  c(0.4,0.5,0.6,0.7)#
omega  <-  0.3#
omega <- as.double(omega)#
mbd <- 2 * max(1-omega, omega)#
nlam <- length(ulam)#
eps <- 10e-12#
maxit  <-  1e6
npass
alpmat
dim(alpmat)
dl <- function(r, omega)#
{#
	d = 2.0*ifelse(r>0, omega, 1-omega)*r	#
}
l=1
B <- alpmat
ri <- y-(cbind(1,Kmat)%*%B[,l])
ri
L = dl(ri)
L = dl(ri,omega)
L
yxl <- rbind(1,Kmat) %*% L
yxl <- - rbind(1,Kmat) %*% L / nobs + 2 * ulam[l] * cbind(0,rbind(0,Kmat)) %*% alpmat[, l]
yxl
ulam  <-  c(0.4,0.5,0.6,0.7)#
omega  <-  0.3#
omega <- as.double(omega)#
mbd <- 2 * max(1-omega, omega)#
nlam <- length(ulam)#
eps <- 10e-14#
maxit  <-  1e6
y <- as.double(y)#
    if (omega <= 0 || omega >= 1) #
        stop("omega must be in (0,1)")#
	omega <- as.double(omega)#
	mbd <- 2 * max(1-omega, omega)#
	##################################################################################
    eigen_result <- eigen(Kmat, symmetric = TRUE)#
	Umat <- eigen_result$vectors#
	Dvec <- eigen_result$values#
	Ksum <- colSums(Kmat)#
	Bmat <- - Ksum %o% Ksum / nobs#
	##################################################################################
	K0 = rbind(0, cbind(0, Kmat))#
    Ki = rbind(1, Kmat)#
	npass <- rep(0,nlam)#
    r <- y # r = 0 in classification case#
	alpmat <- matrix(0, nobs+1, nlam)#
	alpvec = rep(0, nobs+1)#
	for(l in 1:nlam) {#
		dif <- rep(NA, nobs+1)#
		# computing Ku inverse#
		Ainv <- Umat %*% diag(1/(Dvec^2 + 2*nobs*ulam[l]*Dvec/mbd)) %*% t(Umat)#
		BAmat <- Bmat %*% Ainv#
		Ginv <- 1 / (1 + sum(diag(BAmat)))#
		Qinv <- Ainv - Ginv * Ainv %*% BAmat#
		QKsum <- Qinv %*% Ksum / nobs#
		Mtmp <- (1 + crossprod(QKsum,Ksum)) / nobs#
		KUinv <- matrix(NA, nobs+1, nobs+1)#
		KUinv[1, 1] <- Mtmp#
		KUinv[1, 2:(nobs+1)]  <- -QKsum#
		KUinv[2:(nobs+1), 1]  <- -QKsum#
		KUinv[2:(nobs+1), 2:(nobs+1)]  <- Qinv#
		# for debug#
		# KUtmp = rbind(c(nobs, Ksum), cbind(Ksum, Kmat%*%Kmat + 2*nobs*ulam[l]*Kmat / mbd))#
		# KUinv1  <- solve(KUtmp)#
		# update alpha#
		oldalpvec = alpvec#
		while(1){#
		    phi <- 2.0*ifelse(r>0, omega, 1-omega)*r#
		    oldalpvec <- alpvec#
		    alpvec <-  oldalpvec + (2*nobs/mbd) * KUinv %*% (-ulam[l]*K0%*%oldalpvec + 0.5*Ki%*%phi/nobs) #
		    alpvec <-  drop(alpvec)#
		    dif <- alpvec - oldalpvec#
		    r <- r - dif %*% Ki#
		    r <- drop(r)#
		    if(sum(dif^2)/sum(oldalpvec^2) < eps) break#
		    npass[l] = npass[l] + 1#
		    if(sum(npass) > maxit) break#
		}#
		alpmat[, l] <- alpvec#
		if(sum(npass) > maxit) {#
			break#
			jerr = -l#
		}#
	}
setwd('/Users/emeryyi/Dropbox/Research/googleproject/kerneltool/R')
B <- alpmat#
for (l in 1:nlam)#
{#
	ri <- y-(cbind(1,Kmat)%*%B[,l])#
	L = dl(ri,omega)#
	yxl <- - rbind(1,Kmat) %*% L / nobs + 2 * ulam[l] * cbind(0,rbind(0,Kmat)) %*% alpmat[, l]#
	if (crossprod(yxl)>1e-6) print(paste("this is",crossprod(yxl)," at ",l))#
}
